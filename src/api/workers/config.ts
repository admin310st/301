// src/api/workers/config.ts

/**
 * Wrangler Config Generator
 *
 * Generates and stores wrangler.toml configurations for client workers.
 * Supports two worker types:
 * - health: Domain health monitoring (301-client)
 * - tds: Traffic distribution system (301-tds)
 */

import { Context } from "hono";
import { Env } from "../types/worker";
import { requireOwner } from "../lib/auth";
import { listKeys, getDecryptedKey } from "../integrations/keys/storage";
import { setupD1 } from "../integrations/providers/cloudflare/d1";
import {
  setWorkerSecrets,
  checkWorkerExists,
} from "../integrations/providers/cloudflare/workers";
import { signJWT } from "../lib/jwt";

// ============================================================
// TYPES
// ============================================================

export type WorkerType = "health" | "tds";

export interface WorkerRoute {
  pattern: string;
  zone_id: string;
  zone_name?: string;
}

export interface WorkerConfig {
  id: number;
  account_id: number;
  worker_type: WorkerType;
  worker_name: string;
  d1_database_id: string | null;
  d1_database_name: string | null;
  config_toml: string | null;
  secrets_configured: string[];
  routes: WorkerRoute[];
  cron_schedule: string;
  deployed: boolean;
  last_deployed_at: string | null;
  created_at: string;
  updated_at: string;
}

interface GenerateConfigRequest {
  worker_type: WorkerType;
  worker_name?: string;
  d1_database_id?: string;
  d1_database_name?: string;
  cron_schedule?: string;
  routes?: WorkerRoute[];
  webhook_url?: string;
}

interface UpdateConfigRequest {
  d1_database_id?: string;
  d1_database_name?: string;
  cron_schedule?: string;
  routes?: WorkerRoute[];
  secrets_configured?: string[];
  deployed?: boolean;
}

// ============================================================
// CONSTANTS
// ============================================================

const DEFAULT_WORKER_NAMES: Record<WorkerType, string> = {
  health: "301-client",
  tds: "301-tds",
};

const DEFAULT_D1_NAMES: Record<WorkerType, string> = {
  health: "301-client",
  tds: "301-tds",
};

const DEFAULT_CRON: Record<WorkerType, string> = {
  health: "0 */12 * * *",  // Every 12 hours
  tds: "",                  // No cron for TDS
};

const DEFAULT_WEBHOOK_URL = "https://301.st/webhook/health";

// ============================================================
// TOML GENERATORS
// ============================================================

/**
 * Generate wrangler.toml for Health worker
 */
function generateHealthToml(config: {
  workerName: string;
  d1DatabaseId: string;
  d1DatabaseName: string;
  cronSchedule: string;
  webhookUrl: string;
}): string {
  return `# ============================================================
# 301 Health Worker Configuration
# Generated by 301.st
# ============================================================
#
# Secrets (set via POST /health/client/setup or wrangler secret put):
#   JWT_TOKEN    - JWT for webhook auth
#   ACCOUNT_ID   - 301.st account ID
#   VT_API_KEY   - VirusTotal API key (optional)
#   CF_API_TOKEN - CF token for phishing check (optional)
#
# ============================================================

name = "${config.workerName}"
main = "index.ts"
compatibility_date = "2025-01-01"

# ============================================================
# Variables
# ============================================================

[vars]
WEBHOOK_URL = "${config.webhookUrl}"

# ============================================================
# D1 Database
# ============================================================

[[d1_databases]]
binding = "DB"
database_name = "${config.d1DatabaseName}"
database_id = "${config.d1DatabaseId}"

# ============================================================
# Cron Triggers
# ============================================================
#
# Schedule intervals:
# - "0 */12 * * *" = every 12 hours (default)
# - "0 */6 * * *"  = every 6 hours (for large domain counts)
#
# ============================================================

[triggers]
crons = ["${config.cronSchedule}"]

# ============================================================
# Workers.dev Access
# ============================================================

workers_dev = true
`;
}

/**
 * Generate wrangler.toml for TDS worker
 */
function generateTdsToml(config: {
  workerName: string;
  d1DatabaseId: string;
  d1DatabaseName: string;
  routes: WorkerRoute[];
}): string {
  // Format routes for TOML
  const routesSection = config.routes.length > 0
    ? config.routes.map(r =>
        `  { pattern = "${r.pattern}", zone_name = "${r.zone_name || ""}" }`
      ).join(",\n")
    : `  # Add routes here after adding domains
  # { pattern = "example.com/*", zone_name = "example.com" }`;

  return `# ============================================================
# 301 TDS Worker Configuration
# Generated by 301.st
# ============================================================
#
# Secrets (set via POST /workers/config/tds/setup or wrangler secret put):
#   JWT_TOKEN    - JWT for API auth
#   ACCOUNT_ID   - 301.st account ID
#
# ============================================================

name = "${config.workerName}"
main = "index.ts"
compatibility_date = "2025-01-01"

# ============================================================
# Variables
# ============================================================

[vars]
API_URL = "https://301.st"

# ============================================================
# D1 Database (for caching rules)
# ============================================================

[[d1_databases]]
binding = "DB"
database_name = "${config.d1DatabaseName}"
database_id = "${config.d1DatabaseId}"

# ============================================================
# Routes
# ============================================================
#
# Each route binds this worker to a domain pattern.
# Worker code uses hostname to determine which TDS rules apply.
#
# ============================================================

routes = [
${routesSection}
]

# ============================================================
# Workers.dev Access (for testing)
# ============================================================

workers_dev = true
`;
}

/**
 * Generate TOML based on worker type
 */
export function generateWranglerToml(
  workerType: WorkerType,
  config: {
    workerName: string;
    d1DatabaseId: string;
    d1DatabaseName: string;
    cronSchedule?: string;
    webhookUrl?: string;
    routes?: WorkerRoute[];
  }
): string {
  if (workerType === "health") {
    return generateHealthToml({
      workerName: config.workerName,
      d1DatabaseId: config.d1DatabaseId,
      d1DatabaseName: config.d1DatabaseName,
      cronSchedule: config.cronSchedule || DEFAULT_CRON.health,
      webhookUrl: config.webhookUrl || DEFAULT_WEBHOOK_URL,
    });
  } else {
    return generateTdsToml({
      workerName: config.workerName,
      d1DatabaseId: config.d1DatabaseId,
      d1DatabaseName: config.d1DatabaseName,
      routes: config.routes || [],
    });
  }
}

// ============================================================
// DATABASE OPERATIONS
// ============================================================

/**
 * Get worker config from database
 */
export async function getWorkerConfig(
  env: Env,
  accountId: number,
  workerType: WorkerType
): Promise<WorkerConfig | null> {
  const row = await env.DB301.prepare(`
    SELECT * FROM client_worker_configs
    WHERE account_id = ? AND worker_type = ?
  `).bind(accountId, workerType).first<{
    id: number;
    account_id: number;
    worker_type: string;
    worker_name: string;
    d1_database_id: string | null;
    d1_database_name: string | null;
    config_toml: string | null;
    secrets_configured: string;
    routes: string;
    cron_schedule: string;
    deployed: number;
    last_deployed_at: string | null;
    created_at: string;
    updated_at: string;
  }>();

  if (!row) return null;

  return {
    id: row.id,
    account_id: row.account_id,
    worker_type: row.worker_type as WorkerType,
    worker_name: row.worker_name,
    d1_database_id: row.d1_database_id,
    d1_database_name: row.d1_database_name,
    config_toml: row.config_toml,
    secrets_configured: JSON.parse(row.secrets_configured || "[]"),
    routes: JSON.parse(row.routes || "[]"),
    cron_schedule: row.cron_schedule,
    deployed: row.deployed === 1,
    last_deployed_at: row.last_deployed_at,
    created_at: row.created_at,
    updated_at: row.updated_at,
  };
}

/**
 * Get all worker configs for account
 */
export async function getWorkerConfigs(
  env: Env,
  accountId: number
): Promise<WorkerConfig[]> {
  const rows = await env.DB301.prepare(`
    SELECT * FROM client_worker_configs
    WHERE account_id = ?
    ORDER BY worker_type
  `).bind(accountId).all<{
    id: number;
    account_id: number;
    worker_type: string;
    worker_name: string;
    d1_database_id: string | null;
    d1_database_name: string | null;
    config_toml: string | null;
    secrets_configured: string;
    routes: string;
    cron_schedule: string;
    deployed: number;
    last_deployed_at: string | null;
    created_at: string;
    updated_at: string;
  }>();

  return rows.results.map(row => ({
    id: row.id,
    account_id: row.account_id,
    worker_type: row.worker_type as WorkerType,
    worker_name: row.worker_name,
    d1_database_id: row.d1_database_id,
    d1_database_name: row.d1_database_name,
    config_toml: row.config_toml,
    secrets_configured: JSON.parse(row.secrets_configured || "[]"),
    routes: JSON.parse(row.routes || "[]"),
    cron_schedule: row.cron_schedule,
    deployed: row.deployed === 1,
    last_deployed_at: row.last_deployed_at,
    created_at: row.created_at,
    updated_at: row.updated_at,
  }));
}

/**
 * Create or update worker config
 */
export async function upsertWorkerConfig(
  env: Env,
  accountId: number,
  workerType: WorkerType,
  data: {
    workerName?: string;
    d1DatabaseId?: string;
    d1DatabaseName?: string;
    configToml?: string;
    secretsConfigured?: string[];
    routes?: WorkerRoute[];
    cronSchedule?: string;
    deployed?: boolean;
  }
): Promise<WorkerConfig> {
  const existing = await getWorkerConfig(env, accountId, workerType);

  if (existing) {
    // Update
    await env.DB301.prepare(`
      UPDATE client_worker_configs SET
        worker_name = COALESCE(?, worker_name),
        d1_database_id = COALESCE(?, d1_database_id),
        d1_database_name = COALESCE(?, d1_database_name),
        config_toml = COALESCE(?, config_toml),
        secrets_configured = COALESCE(?, secrets_configured),
        routes = COALESCE(?, routes),
        cron_schedule = COALESCE(?, cron_schedule),
        deployed = COALESCE(?, deployed),
        last_deployed_at = CASE WHEN ? = 1 THEN CURRENT_TIMESTAMP ELSE last_deployed_at END,
        updated_at = CURRENT_TIMESTAMP
      WHERE account_id = ? AND worker_type = ?
    `).bind(
      data.workerName || null,
      data.d1DatabaseId || null,
      data.d1DatabaseName || null,
      data.configToml || null,
      data.secretsConfigured ? JSON.stringify(data.secretsConfigured) : null,
      data.routes ? JSON.stringify(data.routes) : null,
      data.cronSchedule || null,
      data.deployed !== undefined ? (data.deployed ? 1 : 0) : null,
      data.deployed ? 1 : 0,
      accountId,
      workerType
    ).run();
  } else {
    // Insert
    const workerName = data.workerName || DEFAULT_WORKER_NAMES[workerType];
    const d1Name = data.d1DatabaseName || DEFAULT_D1_NAMES[workerType];
    const cronSchedule = data.cronSchedule || DEFAULT_CRON[workerType];

    await env.DB301.prepare(`
      INSERT INTO client_worker_configs (
        account_id, worker_type, worker_name,
        d1_database_id, d1_database_name, config_toml,
        secrets_configured, routes, cron_schedule, deployed
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      accountId,
      workerType,
      workerName,
      data.d1DatabaseId || null,
      d1Name,
      data.configToml || null,
      JSON.stringify(data.secretsConfigured || []),
      JSON.stringify(data.routes || []),
      cronSchedule,
      data.deployed ? 1 : 0
    ).run();
  }

  return (await getWorkerConfig(env, accountId, workerType))!;
}

// ============================================================
// HTTP HANDLERS
// ============================================================

/**
 * POST /workers/config
 *
 * Generate and save worker config
 */
export async function handleGenerateConfig(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;

  // Parse body
  let body: GenerateConfigRequest;
  try {
    body = await c.req.json();
  } catch {
    return c.json({ ok: false, error: "invalid_json" }, 400);
  }

  if (!body.worker_type || !["health", "tds"].includes(body.worker_type)) {
    return c.json({ ok: false, error: "invalid_worker_type" }, 400);
  }

  const workerType = body.worker_type as WorkerType;
  const workerName = body.worker_name || DEFAULT_WORKER_NAMES[workerType];
  const d1Name = body.d1_database_name || DEFAULT_D1_NAMES[workerType];
  const d1Id = body.d1_database_id || "YOUR_DATABASE_ID_HERE";
  const cronSchedule = body.cron_schedule || DEFAULT_CRON[workerType];

  // Generate TOML
  const configToml = generateWranglerToml(workerType, {
    workerName,
    d1DatabaseId: d1Id,
    d1DatabaseName: d1Name,
    cronSchedule,
    webhookUrl: body.webhook_url || DEFAULT_WEBHOOK_URL,
    routes: body.routes,
  });

  // Save to database
  const config = await upsertWorkerConfig(env, accountId, workerType, {
    workerName,
    d1DatabaseId: d1Id !== "YOUR_DATABASE_ID_HERE" ? d1Id : undefined,
    d1DatabaseName: d1Name,
    configToml,
    routes: body.routes,
    cronSchedule,
  });

  return c.json({
    ok: true,
    config: {
      worker_type: config.worker_type,
      worker_name: config.worker_name,
      d1_database_name: config.d1_database_name,
      cron_schedule: config.cron_schedule,
      routes: config.routes,
    },
    toml: configToml,
  });
}

/**
 * GET /workers/config
 *
 * Get all worker configs for account
 */
export async function handleGetConfigs(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;

  const configs = await getWorkerConfigs(env, accountId);

  return c.json({
    ok: true,
    configs: configs.map(cfg => ({
      worker_type: cfg.worker_type,
      worker_name: cfg.worker_name,
      d1_database_id: cfg.d1_database_id,
      d1_database_name: cfg.d1_database_name,
      secrets_configured: cfg.secrets_configured,
      routes: cfg.routes,
      cron_schedule: cfg.cron_schedule,
      deployed: cfg.deployed,
      last_deployed_at: cfg.last_deployed_at,
      created_at: cfg.created_at,
      updated_at: cfg.updated_at,
    })),
  });
}

/**
 * GET /workers/config/:type
 *
 * Get specific worker config
 */
export async function handleGetConfig(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;
  const workerType = c.req.param("type") as WorkerType;

  if (!["health", "tds"].includes(workerType)) {
    return c.json({ ok: false, error: "invalid_worker_type" }, 400);
  }

  const config = await getWorkerConfig(env, accountId, workerType);

  if (!config) {
    return c.json({ ok: false, error: "config_not_found" }, 404);
  }

  return c.json({
    ok: true,
    config: {
      worker_type: config.worker_type,
      worker_name: config.worker_name,
      d1_database_id: config.d1_database_id,
      d1_database_name: config.d1_database_name,
      secrets_configured: config.secrets_configured,
      routes: config.routes,
      cron_schedule: config.cron_schedule,
      deployed: config.deployed,
      last_deployed_at: config.last_deployed_at,
    },
    toml: config.config_toml,
  });
}

/**
 * PUT /workers/config/:type
 *
 * Update worker config
 */
export async function handleUpdateConfig(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;
  const workerType = c.req.param("type") as WorkerType;

  if (!["health", "tds"].includes(workerType)) {
    return c.json({ ok: false, error: "invalid_worker_type" }, 400);
  }

  // Parse body
  let body: UpdateConfigRequest;
  try {
    body = await c.req.json();
  } catch {
    return c.json({ ok: false, error: "invalid_json" }, 400);
  }

  const existing = await getWorkerConfig(env, accountId, workerType);
  if (!existing) {
    return c.json({ ok: false, error: "config_not_found" }, 404);
  }

  // Merge updates
  const d1Id = body.d1_database_id || existing.d1_database_id || "YOUR_DATABASE_ID_HERE";
  const d1Name = body.d1_database_name || existing.d1_database_name || DEFAULT_D1_NAMES[workerType];
  const cronSchedule = body.cron_schedule || existing.cron_schedule;
  const routes = body.routes || existing.routes;

  // Regenerate TOML
  const configToml = generateWranglerToml(workerType, {
    workerName: existing.worker_name,
    d1DatabaseId: d1Id,
    d1DatabaseName: d1Name,
    cronSchedule,
    routes,
  });

  // Update database
  const config = await upsertWorkerConfig(env, accountId, workerType, {
    d1DatabaseId: body.d1_database_id,
    d1DatabaseName: body.d1_database_name,
    configToml,
    secretsConfigured: body.secrets_configured,
    routes: body.routes,
    cronSchedule: body.cron_schedule,
    deployed: body.deployed,
  });

  return c.json({
    ok: true,
    config: {
      worker_type: config.worker_type,
      worker_name: config.worker_name,
      d1_database_id: config.d1_database_id,
      d1_database_name: config.d1_database_name,
      routes: config.routes,
      cron_schedule: config.cron_schedule,
      deployed: config.deployed,
    },
    toml: configToml,
  });
}

/**
 * GET /workers/config/:type/download
 *
 * Download wrangler.toml file
 */
export async function handleDownloadConfig(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;
  const workerType = c.req.param("type") as WorkerType;

  if (!["health", "tds"].includes(workerType)) {
    return c.json({ ok: false, error: "invalid_worker_type" }, 400);
  }

  const config = await getWorkerConfig(env, accountId, workerType);

  if (!config || !config.config_toml) {
    return c.json({ ok: false, error: "config_not_found" }, 404);
  }

  return new Response(config.config_toml, {
    headers: {
      "Content-Type": "application/toml",
      "Content-Disposition": `attachment; filename="wrangler.toml"`,
    },
  });
}

/**
 * POST /workers/config/:type/routes
 *
 * Add route to TDS worker config
 */
export async function handleAddRoute(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;
  const workerType = c.req.param("type") as WorkerType;

  if (workerType !== "tds") {
    return c.json({ ok: false, error: "routes_only_for_tds" }, 400);
  }

  // Parse body
  let body: WorkerRoute;
  try {
    body = await c.req.json();
  } catch {
    return c.json({ ok: false, error: "invalid_json" }, 400);
  }

  if (!body.pattern || !body.zone_id) {
    return c.json({ ok: false, error: "pattern_and_zone_id_required" }, 400);
  }

  const config = await getWorkerConfig(env, accountId, workerType);

  if (!config) {
    return c.json({ ok: false, error: "config_not_found" }, 404);
  }

  // Check for duplicate
  const exists = config.routes.some(r => r.pattern === body.pattern);
  if (exists) {
    return c.json({ ok: false, error: "route_already_exists" }, 409);
  }

  // Add route
  const routes = [...config.routes, body];

  // Regenerate TOML
  const d1Id = config.d1_database_id || "YOUR_DATABASE_ID_HERE";
  const configToml = generateWranglerToml(workerType, {
    workerName: config.worker_name,
    d1DatabaseId: d1Id,
    d1DatabaseName: config.d1_database_name || DEFAULT_D1_NAMES[workerType],
    routes,
  });

  // Update database
  await upsertWorkerConfig(env, accountId, workerType, {
    routes,
    configToml,
  });

  return c.json({
    ok: true,
    routes,
  });
}

/**
 * DELETE /workers/config/:type/routes
 *
 * Remove route from TDS worker config
 */
export async function handleRemoveRoute(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;
  const workerType = c.req.param("type") as WorkerType;

  if (workerType !== "tds") {
    return c.json({ ok: false, error: "routes_only_for_tds" }, 400);
  }

  // Parse body
  let body: { pattern: string };
  try {
    body = await c.req.json();
  } catch {
    return c.json({ ok: false, error: "invalid_json" }, 400);
  }

  if (!body.pattern) {
    return c.json({ ok: false, error: "pattern_required" }, 400);
  }

  const config = await getWorkerConfig(env, accountId, workerType);

  if (!config) {
    return c.json({ ok: false, error: "config_not_found" }, 404);
  }

  // Remove route
  const routes = config.routes.filter(r => r.pattern !== body.pattern);

  if (routes.length === config.routes.length) {
    return c.json({ ok: false, error: "route_not_found" }, 404);
  }

  // Regenerate TOML
  const d1Id = config.d1_database_id || "YOUR_DATABASE_ID_HERE";
  const configToml = generateWranglerToml(workerType, {
    workerName: config.worker_name,
    d1DatabaseId: d1Id,
    d1DatabaseName: config.d1_database_name || DEFAULT_D1_NAMES[workerType],
    routes,
  });

  // Update database
  await upsertWorkerConfig(env, accountId, workerType, {
    routes,
    configToml,
  });

  return c.json({
    ok: true,
    routes,
  });
}

// ============================================================
// TDS D1 SCHEMA
// ============================================================

const TDS_CLIENT_SCHEMA = `
-- TDS Rules Cache
CREATE TABLE IF NOT EXISTS tds_rules (
    id INTEGER PRIMARY KEY,
    domain_name TEXT NOT NULL,
    priority INTEGER DEFAULT 0,
    conditions TEXT NOT NULL,
    action TEXT NOT NULL,
    action_url TEXT,
    status_code INTEGER DEFAULT 302,
    active INTEGER DEFAULT 1,
    synced_at TEXT DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_tds_rules_domain
ON tds_rules(domain_name, active, priority DESC);

-- Domain Config Cache
CREATE TABLE IF NOT EXISTS domain_config (
    domain_name TEXT PRIMARY KEY,
    tds_enabled INTEGER DEFAULT 1,
    default_action TEXT DEFAULT 'pass',
    default_url TEXT,
    smartshield_enabled INTEGER DEFAULT 0,
    bot_action TEXT DEFAULT 'pass',
    bot_redirect_url TEXT,
    synced_at TEXT DEFAULT CURRENT_TIMESTAMP
);

-- Sync Status
CREATE TABLE IF NOT EXISTS sync_status (
    key TEXT PRIMARY KEY,
    value TEXT,
    updated_at TEXT DEFAULT CURRENT_TIMESTAMP
);

INSERT OR IGNORE INTO sync_status (key, value) VALUES ('last_rules_sync', NULL);
INSERT OR IGNORE INTO sync_status (key, value) VALUES ('last_config_sync', NULL);
`;

// ============================================================
// UNIFIED SETUP HANDLER
// ============================================================

/**
 * POST /workers/config/:type/setup
 *
 * Setup worker on client's CF account:
 * 1. Create D1 database
 * 2. Set worker secrets (JWT_TOKEN, ACCOUNT_ID)
 * 3. Save config to database
 */
export async function handleSetupWorker(c: Context<{ Bindings: Env }>): Promise<Response> {
  const env = c.env;

  // Auth
  const auth = await requireOwner(c, env);
  if (!auth) {
    return c.json({ ok: false, error: "owner_required" }, 403);
  }

  const { account_id: accountId } = auth;
  const workerType = c.req.param("type") as WorkerType;

  if (!["health", "tds"].includes(workerType)) {
    return c.json({ ok: false, error: "invalid_worker_type" }, 400);
  }

  // Parse body
  let body: { worker_name?: string; skip_d1?: boolean } = {};
  try {
    body = await c.req.json();
  } catch {
    // Empty body is ok
  }

  const workerName = body.worker_name || DEFAULT_WORKER_NAMES[workerType];
  const d1Name = DEFAULT_D1_NAMES[workerType];
  const skipD1 = body.skip_d1 || false;

  // Get CF integration
  const cfKeys = await listKeys(env, accountId, "cloudflare");
  const activeCfKey = cfKeys.find((k) => k.status === "active");

  if (!activeCfKey) {
    return c.json({
      ok: false,
      error: "cloudflare_integration_required",
      message: "Please add Cloudflare integration first via POST /integrations/cloudflare/init",
    }, 400);
  }

  let cfToken: string;
  let cfAccountId: string;
  try {
    const decrypted = await getDecryptedKey(env, activeCfKey.id);
    if (!decrypted) {
      return c.json({ ok: false, error: "cf_key_decrypt_failed" }, 500);
    }
    cfToken = decrypted.secrets.token;
    cfAccountId = activeCfKey.external_account_id!;
  } catch (err) {
    return c.json({
      ok: false,
      error: err instanceof Error ? err.message : "cf_key_error",
    }, 400);
  }

  if (!cfAccountId) {
    return c.json({ ok: false, error: "cf_account_id_missing" }, 400);
  }

  const result: {
    ok: boolean;
    error?: string;
    d1?: { database_id: string; database_name: string; created: boolean };
    worker?: { name: string; exists: boolean; secrets_set: string[]; secrets_errors: Array<{ name: string; error: string }> };
    jwt_token?: string;
    config_download_url?: string;
  } = { ok: true };

  // Setup D1
  if (!skipD1) {
    const schema = workerType === "tds" ? TDS_CLIENT_SCHEMA : undefined;
    const d1Result = await setupD1({
      cfAccountId,
      token: cfToken,
      dbName: d1Name,
      schema,
    });

    if (!d1Result.ok) {
      return c.json({
        ok: false,
        error: "d1_setup_failed",
        details: d1Result.error,
      }, 500);
    }

    result.d1 = {
      database_id: d1Result.database_id!,
      database_name: d1Result.database_name!,
      created: d1Result.created || false,
    };
  }

  // Check worker exists
  const workerCheck = await checkWorkerExists(cfAccountId, workerName, cfToken);

  if (!workerCheck.exists) {
    // Save config anyway for user to download
    const configToml = generateWranglerToml(workerType, {
      workerName,
      d1DatabaseId: result.d1?.database_id || "YOUR_DATABASE_ID_HERE",
      d1DatabaseName: d1Name,
    });

    await upsertWorkerConfig(env, accountId, workerType, {
      workerName,
      d1DatabaseId: result.d1?.database_id,
      d1DatabaseName: d1Name,
      configToml,
    });

    return c.json({
      ok: false,
      error: "worker_not_deployed",
      message: `Worker "${workerName}" not found. Download wrangler.toml and deploy with 'npx wrangler deploy'.`,
      d1: result.d1,
      config_download_url: `/workers/config/${workerType}/download`,
    }, 400);
  }

  // Generate JWT
  const jwtToken = await signJWT(
    {
      type: workerType === "health" ? "client_worker" : "tds_worker",
      acc: accountId,
      cf_account_id: cfAccountId,
    },
    env,
    "365d"
  );

  // Set secrets
  const secrets: Record<string, string> = {
    JWT_TOKEN: jwtToken,
    ACCOUNT_ID: String(accountId),
  };

  const secretsResult = await setWorkerSecrets(cfAccountId, workerName, secrets, cfToken);

  result.worker = {
    name: workerName,
    exists: true,
    secrets_set: secretsResult.set,
    secrets_errors: secretsResult.errors,
  };

  result.jwt_token = jwtToken;

  // Save config to database
  const configToml = generateWranglerToml(workerType, {
    workerName,
    d1DatabaseId: result.d1?.database_id || "YOUR_DATABASE_ID_HERE",
    d1DatabaseName: d1Name,
  });

  await upsertWorkerConfig(env, accountId, workerType, {
    workerName,
    d1DatabaseId: result.d1?.database_id,
    d1DatabaseName: d1Name,
    configToml,
    secretsConfigured: secretsResult.set,
    deployed: true,
  });

  if (secretsResult.errors.length > 0) {
    return c.json({
      ok: false,
      error: "secrets_setup_partial",
      ...result,
    }, 500);
  }

  return c.json(result);
}
